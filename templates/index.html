<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>YOLO and MediaPipe Hands Detection</title>
    <style>
        #video, #canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <h1>YOLO and MediaPipe Hands Detection with Webcam</h1>
    <video id="video" playsinline autoplay></video>
    <canvas id="canvas" width="1280px" height="720px"></canvas>
    <p id="status"></p>
    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');
        const status = document.getElementById('status');
        const ws = new WebSocket('ws://localhost:8000/ws');

        let hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        if (navigator.mediaDevices.getUserMedia) {
            navigator.mediaDevices.getUserMedia({ video: true })
                .then(function(stream) {
                    video.srcObject = stream;
                    streamVideoToServer();
                })
                .catch(function(error) {
                    console.log("웹캠 접근에 실패했습니다:", error);
                });
        }

        function streamVideoToServer() {
            video.addEventListener('play', () => {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
    
                setInterval(() => {
                    if (video.readyState === video.HAVE_ENOUGH_DATA) {
                        context.drawImage(video, 0, 0, canvas.width, canvas.height);
                        const imageData = canvas.toDataURL('image/jpeg');
                        if (imageData.length > 23) {
                            ws.send(imageData);
                            hands.send({image: video});
                        } else {
                            console.log('데이터가 비어 있습니다.');
                        }
                    }
                }, 300);
            });
        }
    
        ws.onmessage = function(event) {
            let data;
            try {
                data = JSON.parse(event.data);
                console.log("Received data:", data);  // 수신된 데이터 출력
            } catch (e) {
                console.error("Received non-JSON message:", event.data);
                status.textContent = "Error: Received non-JSON message.";
                return;
            }

            if (data.error) {
                status.textContent = data.error;
                return;
            }

            if (Array.isArray(data)) {  // 좌표 데이터가 배열 형태로 제공된 경우
                drawBoxes(data);
            } else {
                status.textContent = "Unexpected message format";
            }
        };

        function drawBoxes(boxes) {
            context.clearRect(0, 0, canvas.width, canvas.height);  // 이전 프레임의 그림 삭제
            context.drawImage(video, 0, 0, canvas.width, canvas.height);  // 현재 비디오 프레임 그리기
            boxes.forEach(box => {
                console.log("Drawing box:", box);  // 그릴 박스 정보 출력
                context.beginPath();
                context.rect(box.coordinates[0], box.coordinates[1], box.coordinates[2] - box.coordinates[0], box.coordinates[3] - box.coordinates[1]);
                context.strokeStyle = 'red';
                context.lineWidth = 2;
                context.stroke();
            });
        }

        function onResults(results) {
            context.save();
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.drawImage(results.image, 0, 0, canvas.width, canvas.height);
            if (results.multiHandLandmarks) {
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(context, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 5});
                    drawLandmarks(context, landmarks, {color: '#FF0000', lineWidth: 2});
                }
            }
            context.restore();
        }
    </script>
</body>
</html>
