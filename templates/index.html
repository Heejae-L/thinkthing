<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>YOLO and MediaPipe Hands Detection</title>
    <style>
        #video, #canvas {
            position: absolute;
            top: 100px;  /* 제목을 가리지 않도록 조정 */
            left: 0;
        }
        #distance {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: white;
            padding: 5px;
            border-radius: 5px;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <h1>YOLO and MediaPipe Hands Detection with Webcam</h1>
    <video id="video" playsinline autoplay></video>
    <canvas id="canvas" width="1280px" height="720px"></canvas>
    <p id="status"></p>
    <div id="distance"></div>
    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');
        const status = document.getElementById('status');
        const distanceDisplay = document.getElementById('distance');
        const ws = new WebSocket('ws://localhost:8000/ws');

        let hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        let handLandmarks = [];
        let audio = new Audio('/Users/LeeHeejae/projects/thinkthing/sound_files/25.wav');

        if (navigator.mediaDevices.getUserMedia) {
            navigator.mediaDevices.getUserMedia({ video: true })
                .then(function(stream) {
                    video.srcObject = stream;
                    streamVideoToServer();
                })
                .catch(function(error) {
                    console.log("웹캠 접근에 실패했습니다:", error);
                });
        }

        function streamVideoToServer() {
            video.addEventListener('play', () => {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
    
                setInterval(() => {
                    if (video.readyState === video.HAVE_ENOUGH_DATA) {
                        context.drawImage(video, 0, 0, canvas.width, canvas.height);
                        const imageData = canvas.toDataURL('image/jpeg');
                        if (imageData.length > 23) {
                            ws.send(imageData);
                            hands.send({image: video});
                        } else {
                            console.log('데이터가 비어 있습니다.');
                        }
                    }
                }, 300);
            });
        }
    
        ws.onmessage = function(event) {
            let data;
            try {
                data = JSON.parse(event.data);
                console.log("Received data:", data);  // 수신된 데이터 출력
            } catch (e) {
                console.error("Received non-JSON message:", event.data);
                status.textContent = "Error: Received non-JSON message.";
                return;
            }

            if (data.error) {
                status.textContent = data.error;
                return;
            }

            if (Array.isArray(data)) {  // 좌표 데이터가 배열 형태로 제공된 경우
                drawBoxes(data);
                calculateAndDisplayDistances(data);
            } else {
                status.textContent = "Unexpected message format";
            }
        };

        function drawBoxes(boxes) {
            context.clearRect(0, 0, canvas.width, canvas.height);  // 이전 프레임의 그림 삭제
            context.drawImage(video, 0, 0, canvas.width, canvas.height);  // 현재 비디오 프레임 그리기
            boxes.forEach(box => {
                console.log("Drawing box:", box);  // 그릴 박스 정보 출력
                context.beginPath();
                context.rect(box.coordinates[0], box.coordinates[1], box.coordinates[2] - box.coordinates[0], box.coordinates[3] - box.coordinates[1]);
                context.strokeStyle = 'red';
                context.lineWidth = 2;
                context.stroke();

                // Draw tracking ID
                context.fillStyle = 'blue';
                context.font = '16px Arial';
                context.fillText(`ID: ${box.track_id}`, box.coordinates[0], box.coordinates[1] - 10);

                // Draw tracking lines
                if (box.track_history && box.track_history.length > 1) {
                    context.beginPath();
                    context.moveTo(box.track_history[0][0], box.track_history[0][1]);
                    for (let i = 1; i < box.track_history.length; i++) {
                        context.lineTo(box.track_history[i][0], box.track_history[i][1]);
                    }
                    context.strokeStyle = 'blue';
                    context.lineWidth = 2;
                    context.stroke();
                }
            });
        }

        function onResults(results) {
            handLandmarks = [];
            context.save();
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.drawImage(results.image, 0, 0, canvas.width, canvas.height);
            if (results.multiHandLandmarks) {
                for (const landmarks of results.multiHandLandmarks) {
                    handLandmarks.push(landmarks);
                    drawConnectors(context, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 5});
                    drawLandmarks(context, landmarks, {color: '#FF0000', lineWidth: 2});
                }
            }
            context.restore();
        }

        function calculateAndDisplayDistances(boxes) {
            let distanceInfo = "";
            handLandmarks.forEach(hand => {
                hand.forEach(lm => {
                    let handX = lm.x * canvas.width;
                    let handY = lm.y * canvas.height;
                    boxes.forEach(box => {
                        let boxCenterX = (box.coordinates[0] + box.coordinates[2]) / 2;
                        let boxCenterY = (box.coordinates[1] + box.coordinates[3]) / 2;
                        let distance = Math.sqrt(Math.pow(handX - boxCenterX, 2) + Math.pow(handY - boxCenterY, 2));
                        if (distance <= 200) {
                            audio.play();
                        }
                        distanceInfo += `Distance to object ${box.class}: ${Math.round(distance)}px<br>`;
                    });
                });
            });
            distanceDisplay.innerHTML = distanceInfo;
        }
    </script>
</body>
</html>
